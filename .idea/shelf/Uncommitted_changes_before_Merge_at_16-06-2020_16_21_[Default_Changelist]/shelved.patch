Index: src/BoardDetection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import org.opencv.core.*;\r\nimport org.opencv.core.Point;\r\nimport org.opencv.imgcodecs.Imgcodecs;\r\nimport org.opencv.imgproc.Imgproc;\r\n\r\nimport javax.imageio.ImageIO;\r\nimport javax.swing.*;\r\nimport java.awt.*;\r\nimport java.awt.image.BufferedImage;\r\nimport java.awt.image.DataBufferByte;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.*;\r\nimport java.util.List;\r\n\r\npublic class BoardDetection extends JFrame {\r\n\r\n    public BufferedImage imgIn, imgOut;\r\n    public JPanel panel;\r\n    public JLabel input, bw, output;\r\n    public Mat hsvImage;\r\n    public Mat mask;\r\n    public Mat in, persimg, org;\r\n    public Iterator<MatOfPoint> iterator;\r\n    public List<MatOfPoint> contours, apcontours;\r\n    public Integer i;\r\n    private ImageIcon icon0, icon1, icon2;\r\n\r\n    public BoardDetection(String title, String imgname){\r\n        Mat grey = new Mat();\r\n        Mat canny = new Mat();\r\n        Mat cannyimg = new Mat();\r\n        Mat cnthiarchy = new Mat();\r\n        Mat boardimg = new Mat();\r\n        i = 0;\r\n        org = new Mat();\r\n        contours = new ArrayList<>();\r\n        apcontours = new ArrayList<MatOfPoint>( );\r\n        try {\r\n            imgIn = ImageIO.read(new File(imgname));\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            System.exit(1);\r\n        }\r\n        in = Imgcodecs.imread(imgname);\r\n        in.copyTo(boardimg);\r\n\r\n        Imgproc.GaussianBlur(in, in, new Size(5, 5), 0);\r\n\r\n        Imgproc.cvtColor(in, grey, Imgproc.COLOR_BGR2GRAY);\r\n\r\n        Imgproc.Canny(grey, canny, 10, 70);\r\n        canny.copyTo(cannyimg);\r\n        Imgproc.cvtColor(cannyimg, cannyimg,Imgproc.COLOR_GRAY2BGR);\r\n\r\n        Imgproc.findContours(canny,contours,cnthiarchy,Imgproc.RETR_TREE,Imgproc.CHAIN_APPROX_SIMPLE);\r\n\r\n        MatOfPoint maxcnt = findMaxContour(contours);\r\n\r\n        MatOfPoint2f approx = approxContourAsRect(maxcnt);\r\n\r\n        approx = sortApproxContour(approx);\r\n\r\n        printContour(approx);\r\n        Size imgsize = new Size(1500, 1500);\r\n\r\n        //Create an transform matrix of the wished size. 1500x1500.\r\n        Mat dst = Mat.zeros(4,2,CvType.CV_32F);\r\n        dst.put(0,0,0); dst.put(0,1,0);\r\n        dst.put(1,0,imgsize.width-1); dst.put(1,1,0);\r\n        dst.put(2,0,imgsize.width-1); dst.put(2,1,imgsize.height-1);\r\n        dst.put(3,0,0); dst.put(3,1,imgsize.height-1);\r\n\r\n        Mat warpMat = Imgproc.getPerspectiveTransform(approx, dst);\r\n\r\n        persimg = new Mat();\r\n\r\n        Imgproc.warpPerspective(boardimg, persimg, warpMat, imgsize);\r\n        persimg.copyTo(org);\r\n        hsvImage = new Mat();\r\n        mask = new Mat();\r\n        Mat persblur = new Mat();\r\n        Imgproc.GaussianBlur(persimg, persblur, new Size(5, 5), 0);\r\n        Imgproc.cvtColor(persblur, hsvImage, Imgproc.COLOR_BGR2HSV);\r\n        contours.clear();\r\n        Core.inRange(hsvImage,  new Scalar(90,25, 25), new Scalar(150, 255, 255), mask);\r\n        Imgproc.findContours(mask,contours,new Mat(),Imgproc.RETR_EXTERNAL,Imgproc.CHAIN_APPROX_SIMPLE);\r\n\r\n        for(MatOfPoint cont : contours){\r\n            double area = Imgproc.contourArea(cont);\r\n            if (area >= 6000){\r\n                MatOfPoint2f apcontour = approxContourAsRect(cont);\r\n                apcontour = sortApproxContour(apcontour);\r\n                apcontours.add(new MatOfPoint(apcontour.toArray()));\r\n                System.out.println(\"Area of contour = \" + area);\r\n            }\r\n        }\r\n\r\n        Collections.sort(apcontours, new Comparator<MatOfPoint>() {\r\n            @Override\r\n            public int compare(MatOfPoint o1, MatOfPoint o2) {\r\n                double o1x = o1.get(0,0)[0];\r\n                double o1y = o1.get(0,0)[1];\r\n                double o2x = o2.get(0,0)[0];\r\n                double o2y = o2.get(0,0)[1];\r\n                int cmp = 0;\r\n                int resulty = (int) (o1y - o2y);\r\n                if(resulty >= 20 || resulty <= -20)\r\n                    cmp = resulty;\r\n\r\n                //int cmp = Integer.compare((int)o1y, (int)o2y);\r\n                if (cmp != 0) {\r\n                    return cmp;\r\n                }\r\n\r\n                return (int) (o1x - o2x);\r\n\r\n            }\r\n        });\r\n\r\n\r\n\r\n        Imgproc.drawContours(persimg, apcontours, -1, new Scalar(0, 0 ,255), 5);\r\n\r\n\r\n\r\n        imgOut = matToBufferedImage(persimg);\r\n\r\n        input = new JLabel();\r\n        bw = new JLabel();\r\n        output = new JLabel();\r\n\r\n        icon0 = new ImageIcon(imgIn.getScaledInstance(800, 480, Image.SCALE_SMOOTH));\r\n        icon1 = new ImageIcon(matToBufferedImage(mask).getScaledInstance(800, 480, Image.SCALE_SMOOTH));\r\n        icon2 = new ImageIcon(imgOut.getScaledInstance(800, 480, Image.SCALE_SMOOTH));\r\n        input.setIcon(icon0);\r\n        bw.setIcon(icon1);\r\n        output.setIcon(icon2);\r\n        panel = new JPanel();\r\n        panel.add(input);\r\n        panel.add(bw);\r\n        panel.add(output);\r\n        this.setTitle(title);\r\n        this.add(panel);\r\n    }\r\n\r\n    private MatOfPoint findMaxContour(java.util.List<MatOfPoint> contours){\r\n        MatOfPoint maxcnt = new MatOfPoint();\r\n        double maxarea = 0;\r\n        for(int i = 0; i < contours.size(); i++){\r\n            double area = Imgproc.contourArea(contours.get(i));\r\n            if (area >= maxarea) {\r\n                maxarea = area;\r\n                maxcnt = contours.get(i);\r\n            }\r\n        }\r\n        return maxcnt;\r\n    }\r\n    /*\r\n    private MatOfPoint2f approxContourAsRect(MatOfPoint contour){\r\n\r\n        MatOfPoint2f m2f = new MatOfPoint2f(contour.toArray());\r\n        MatOfPoint2f approx = new MatOfPoint2f();\r\n        double epsilon = 0.01 * Imgproc.arcLength(m2f, true);\r\n\r\n        //If are contour has less vertices then 4, then we cannot approximate and we will never be able to isolate the board.\r\n        if(m2f.total() < 4) return null;\r\n        //Find an epsilon which approximates the contour to an rectangle.\r\n        //The higher the epsilon the less vertices. Epsilon can't be zero or below.\r\n        if(m2f.total() > 4) {\r\n            while (approx.total() != 4){\r\n                Imgproc.approxPolyDP(m2f, approx, epsilon, true);\r\n                if(approx.total() > 4){\r\n                    epsilon += 1;\r\n                } else if( approx.total() < 4){\r\n                    epsilon -= 1;\r\n                }\r\n                if (epsilon <= 0) return null;\r\n            }\r\n\r\n        }\r\n\r\n        System.out.println(\"Vertices in approx = \" + approx.total());\r\n        System.out.println(\"Epsilon = \" + epsilon);\r\n        return approx;\r\n    }\r\n    */\r\n\r\n     //This has the potential to be stuck in infinite loop, trying to find an epsilon which approximates to 4. This epsilon might not exist.\r\n    private MatOfPoint2f approxContourAsRect(MatOfPoint contour){\r\n        Thread watchdog = new Thread();\r\n        MatOfPoint2f m2f = new MatOfPoint2f(contour.toArray());\r\n        MatOfPoint2f approx = new MatOfPoint2f();\r\n        double epsilon = 0.01 * Imgproc.arcLength(m2f, true);\r\n        double lepsilon = 0, repsilon = 0;\r\n        Boolean increased = null;\r\n        //If are contour has less vertices then 4, then we cannot approximate and we will never be able to isolate the board.\r\n        if(m2f.total() < 4) {\r\n            System.err.println(\"ERR: Can't approx when contour is already less than 4 vertices\");\r\n            return null;\r\n        }\r\n        //Find an epsilon which approximates the contour to an rectangle.\r\n        //The higher the epsilon the less vertices. Epsilon can't be zero or below.\r\n        if(m2f.total() > 4) {\r\n\r\n            Imgproc.approxPolyDP(m2f, approx, epsilon, true);\r\n            if(approx.total() > 4){\r\n                lepsilon = epsilon;\r\n                repsilon = 2*epsilon;\r\n                while (approx.total() > 4){\r\n                    Imgproc.approxPolyDP(m2f, approx, repsilon, true);\r\n                    repsilon *= 2;\r\n                    if(approx.total() == 4) return approx;\r\n                }\r\n            } else if (approx.total() < 4) {\r\n                repsilon = epsilon;\r\n                lepsilon = 2/epsilon;\r\n                while (approx.total() < 4){\r\n                    Imgproc.approxPolyDP(m2f, approx, lepsilon, true);\r\n                    lepsilon /= 2;\r\n                    if(approx.total() == 4) return approx;\r\n                }\r\n            } else {\r\n                return approx;\r\n            }\r\n\r\n            while (repsilon > lepsilon){\r\n\r\n                    double midepsilon = lepsilon + (repsilon - lepsilon) / 2;\r\n                    Imgproc.approxPolyDP(m2f, approx, midepsilon, true);\r\n\r\n                    System.out.printf(\"Total = %d\\nEpsilon = %f\\n\", approx.total(),midepsilon);\r\n                    // If the element is present at the\r\n                    // middle itself\r\n                    if (approx.total() == 4)\r\n                        return approx;\r\n\r\n                    // If element is smaller than mid, then\r\n                    // it can only be present in left subarray\r\n                    if (approx.total() > 4){\r\n                        lepsilon = midepsilon;\r\n                    } else {\r\n                        repsilon = midepsilon;\r\n                    }\r\n\r\n                if (epsilon <= 0){\r\n                    System.err.println(\"ERR: Epsilon was less than zero\");\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"Vertices in approx = \" + approx.total());\r\n        System.out.println(\"Epsilon = \" + epsilon);\r\n        return approx;\r\n    }\r\n\r\n\r\n    //inspired by: https://www.pyimagesearch.com/2014/08/25/4-point-opencv-getperspective-transform-example/\r\n    private MatOfPoint2f sortApproxContour(MatOfPoint2f approx){\r\n        org.opencv.core.Point[] pntarr = new org.opencv.core.Point[4];\r\n        Point[] approxarr = approx.toArray();\r\n        java.util.List<Double> sumarr = new ArrayList<>();\r\n        List<Double> diffarr = new ArrayList<>();\r\n        //There is always four vertices\r\n        if(approx.total() != 4){\r\n            System.err.println(\"ERR: There should be 4 vertices in the list to sort it!\");\r\n            return null;\r\n        }\r\n        /*\r\n         * Form of the sort:\r\n         * 0: top-left corner will have the smallest sum.\r\n         * 1: top-right corner will have the smallest difference.\r\n         * 2: bottom-right corner will have the largest sum.\r\n         * 3: bottom-left corner will have the largest difference.\r\n         * */\r\n\r\n        //Calculate sum of each point.\r\n        //Calculate difference of each point.\r\n        for (int i = 0; i < approxarr.length; i++){\r\n            sumarr.add(approxarr[i].x + approxarr[i].y);\r\n            diffarr.add(approxarr[i].y - approxarr[i].x);\r\n        }\r\n        //sort for sum\r\n        pntarr[0] = approxarr[sumarr.indexOf(Collections.min(sumarr))];\r\n        pntarr[1] = approxarr[diffarr.indexOf(Collections.min(diffarr))];\r\n        pntarr[2] = approxarr[sumarr.indexOf(Collections.max(sumarr))];\r\n        pntarr[3] = approxarr[diffarr.indexOf(Collections.max(diffarr))];\r\n\r\n        return new MatOfPoint2f(pntarr);\r\n\r\n    }\r\n\r\n    private void printContour(MatOfPoint2f contour){\r\n        for(int i = 0; i < contour.rows(); i++)\r\n            for(int j = 0; j < contour.cols(); j++)\r\n                System.out.printf(\"( %d , %d ) = %f %f \\n\", i, j, contour.get(i, j)[0], contour.get(i, j)[1]);\r\n    }\r\n\r\n    /*https://github.com/opencv-java/object-detection/commit/b6c2afe355c34ff6b103961142f5f0e2601d024f*/\r\n    private BufferedImage matToBufferedImage(Mat original)\r\n    {\r\n        // init\r\n        BufferedImage image = null;\r\n        int width = original.width(), height = original.height(), channels = original.channels();\r\n        byte[] sourcePixels = new byte[width * height * channels];\r\n        original.get(0, 0, sourcePixels);\r\n\r\n        if (original.channels() > 1)\r\n        {\r\n            image = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);\r\n        }\r\n        else\r\n        {\r\n            image = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);\r\n        }\r\n        final byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();\r\n        System.arraycopy(sourcePixels, 0, targetPixels, 0, sourcePixels.length);\r\n\r\n        return image;\r\n    }\r\n\r\n\r\n    public void nextContour(){\r\n        org.copyTo(persimg);\r\n        if (i >= apcontours.size()) i = 0;\r\n\r\n        Imgproc.drawContours(persimg, apcontours, i, new Scalar(0, 0, 0), 2);\r\n        imgOut = matToBufferedImage(persimg);\r\n        icon2 = new ImageIcon(imgOut.getScaledInstance(800, 480, Image.SCALE_SMOOTH));\r\n        output.setIcon(icon2);\r\n        System.out.println(\"Now printing contour: \" + i);\r\n        System.out.printf(\"Coordinates of point (0, 0) = ( %f , %f )\\n\", apcontours.get(i).get(0,0)[0],apcontours.get(i).get(0,0)[1]);\r\n        System.out.println();\r\n\r\n        i++;\r\n    }\r\n    public static void main (String [] args) {\r\n\r\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\r\n\r\n        BoardDetection bd = new BoardDetection(\"Board Detection\", \"res/boardpics/pic4.jpg\");\r\n        bd.setPreferredSize(new Dimension(1800, 1000));\r\n        bd.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // reagér paa luk\r\n        bd.pack();                       // saet vinduets stoerrelse\r\n        bd.setVisible(true);                      // aabn vinduet\r\n        while (bd.isEnabled()){\r\n            try {\r\n                Thread.sleep(1000);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            bd.nextContour();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/BoardDetection.java	(revision ca3e688f6b58e72c57d1eec896e5231181aa9efd)
+++ src/BoardDetection.java	(date 1592314161017)
@@ -85,6 +85,7 @@
         contours.clear();
         Core.inRange(hsvImage,  new Scalar(90,25, 25), new Scalar(150, 255, 255), mask);
         Imgproc.findContours(mask,contours,new Mat(),Imgproc.RETR_EXTERNAL,Imgproc.CHAIN_APPROX_SIMPLE);
+        Imgcodecs.imwrite("out.jpg", mask);
 
         for(MatOfPoint cont : contours){
             double area = Imgproc.contourArea(cont);
@@ -338,7 +339,7 @@
 
         System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
 
-        BoardDetection bd = new BoardDetection("Board Detection", "res/boardpics/pic4.jpg");
+        BoardDetection bd = new BoardDetection("Board Detection", "res/boardMedTing2.jpg");
         bd.setPreferredSize(new Dimension(1800, 1000));
         bd.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // reagér paa luk
         bd.pack();                       // saet vinduets stoerrelse
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_14\" default=\"true\" project-jdk-name=\"12\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision ca3e688f6b58e72c57d1eec896e5231181aa9efd)
+++ .idea/misc.xml	(date 1592314039196)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_14" default="true" project-jdk-name="12" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_12" default="true" project-jdk-name="12" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
 </project>
\ No newline at end of file
