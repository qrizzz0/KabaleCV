Index: src/ColorDetection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import org.opencv.core.*;\r\nimport org.opencv.core.Point;\r\nimport org.opencv.imgcodecs.Imgcodecs;\r\nimport org.opencv.imgproc.Imgproc;\r\n\r\nimport javax.imageio.ImageIO;\r\nimport javax.swing.*;\r\nimport java.awt.*;\r\nimport java.awt.image.BufferedImage;\r\nimport java.awt.image.DataBufferByte;\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.Writer;\r\nimport java.util.ArrayList;\r\n\r\n\r\npublic class ColorDetection {\r\n\r\n    public BufferedImage imgIn, imgOut;\r\n    public JFrame frame;\r\n    public JPanel panel;\r\n    public JLabel input;\r\n    public JLabel output;\r\n    public Mat hsvImage;\r\n    public Mat mask;\r\n    public Mat temp;\r\n    private ImageIcon icon1, icon2;\r\n    private enum Type{\r\n        RIGHT, LEFT, UP, DOWN;\r\n    }\r\n\r\n    public ColorDetection (String imgname) {\r\n\r\n        Mat in;\r\n        Mat blurredImage = new Mat();\r\n        Mat resized_mask = new Mat();\r\n        Mat matchres = new Mat();\r\n        mask = new Mat();\r\n        hsvImage = new Mat();\r\n        try {\r\n            imgIn = ImageIO.read(new File(imgname));\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            System.exit(1);\r\n        }\r\n        in = Imgcodecs.imread(imgname);\r\n        temp = Imgcodecs.imread(\"res/Templates/t1.png\");\r\n\r\n        Imgproc.blur(in, blurredImage, new Size(5, 5));\r\n\r\n        Imgproc.cvtColor(blurredImage, hsvImage, Imgproc.COLOR_BGR2HSV);\r\n        Imgproc.cvtColor(temp, temp, Imgproc.COLOR_BGR2GRAY);\r\n\r\n        Core.inRange(hsvImage,  new Scalar(100,150, 150), new Scalar(120, 255, 255), mask);\r\n\r\n\r\n        //Imgproc.cvtColor(mask, outputImage, Imgproc.COLOR_HSV2BGR);\r\n\r\n        Imgproc.resize(mask, resized_mask, new Size(1280, 720), 0, 0, Imgproc.INTER_LINEAR);\r\n\r\n        Imgproc.matchTemplate(resized_mask, temp, matchres, Imgproc.TM_CCOEFF);\r\n\r\n        Core.MinMaxLocResult mmr = Core.minMaxLoc(matchres);\r\n        Point matchLoc=mmr.maxLoc;\r\n        double [] datapt = new double[resized_mask.channels()];\r\n        double xs = matchLoc.x - 10;\r\n        double ys = matchLoc.y;\r\n        while(datapt[0] == 0.0){\r\n            datapt = resized_mask.get((int) ys, (int) xs);\r\n            ys += 1.0;\r\n            if(resized_mask.rows() <= ys) {\r\n                System.out.println(\"break\");\r\n                break;\r\n            }\r\n        }\r\n        Rect t1 = getSubSqr(resized_mask, (int) ys, (int) xs);\r\n\r\n/*\r\n        ArrayList values = new ArrayList<>();\r\n\r\n        for (int i = 0; i < resized_mask.rows(); i++) {\r\n            for (int j = 0; j < resized_mask.cols(); j++) {\r\n                for(int k = 0; k < resized_mask.channels(); k++) {\r\n                    values.add((int) resized_mask.get(i, j)[k]);\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            FileOutputStream maskdump = new FileOutputStream(\"maskdump.txt\");\r\n            maskdump.write(values.toString().getBytes());\r\n        } catch (IOException e){\r\n            e.printStackTrace();\r\n            System.exit(1);\r\n        }\r\n*/\r\n\r\n        //Draw rectangle on result image\r\n        Imgproc.rectangle(resized_mask, matchLoc, new Point(matchLoc.x + temp.cols(),\r\n                matchLoc.y + temp.rows()), new Scalar(255, 255, 255));\r\n\r\n        Imgproc.rectangle(resized_mask, t1, new Scalar(80, 255, 255));\r\n\r\n        imgOut = matToBufferedImage(resized_mask);\r\n\r\n        input = new JLabel();\r\n        output = new JLabel();\r\n\r\n\r\n        icon1 = new ImageIcon(imgIn.getScaledInstance(800, 600, Image.SCALE_SMOOTH));\r\n        icon2 = new ImageIcon(imgOut.getScaledInstance(800, 600, Image.SCALE_SMOOTH));\r\n        input.setIcon(icon1);\r\n        output.setIcon(icon2);\r\n        panel = new JPanel();\r\n        panel.add(input);\r\n        panel.add(output);\r\n\r\n        frame = new JFrame(\"Color Detection\");\r\n        frame.add(panel);\r\n\r\n    }\r\n    private Rect getSubSqr(Mat mask, int y, int x){\r\n        //find right most point\r\n        int right = dfs(mask, y, x, Type.RIGHT).x;\r\n        //find left most point\r\n        int left = dfs(mask, y, x, Type.LEFT).x;\r\n        //find highest point\r\n        int up = dfs(mask, y, x, Type.UP).y;\r\n        //find lowest point\r\n        int down = dfs(mask, y, x, Type.DOWN).y;\r\n        //create dimension\r\n        return new Rect(left, up, right - left, down - up);\r\n    }\r\n    private java.awt.Point dfs(Mat mask, int y, int x, Type type){\r\n        java.awt.Point thispt = new java.awt.Point(x, y);\r\n        double rightdata, leftdata, updata, downdata;\r\n        switch (type){\r\n            case UP:\r\n                //Get data from up neighbour\r\n                updata = mask.get(y-1, x)[0];\r\n\r\n                //Get data from left neighbour\r\n                leftdata = mask.get(y, x-1)[0];\r\n\r\n                //check neighbour data for valid pixel\r\n                if (updata > 0) return dfs(mask, y-1, x, type);\r\n                else if(leftdata > 0) return dfs(mask, y, x-1, type);\r\n\r\n                //return point of right most valid pixel.\r\n                return thispt;\r\n            case DOWN:\r\n                //Get data from left neighbour\r\n                rightdata = mask.get(y, x+1)[0];\r\n\r\n                //Get data from lower neighbour\r\n                downdata = mask.get(y+1, x)[0];\r\n\r\n                //check neighbour data for valid pixel\r\n                if (downdata > 0) return dfs(mask, y+1, x, type);\r\n                else if(rightdata > 0) return dfs(mask, y, x+1, type);\r\n\r\n                //return point of right most valid pixel.\r\n                return thispt;\r\n            case LEFT:\r\n                //Get data from right neighbour\r\n                leftdata = mask.get(y, x-1)[0];\r\n\r\n                //Get data from lower neighbour\r\n                updata = mask.get(y-1, x)[0];\r\n\r\n                //check neighbour data for valid pixel\r\n                if (leftdata > 0) return dfs(mask, y, x-1, type);\r\n                else if(updata > 0) return dfs(mask, y-1, x, type);\r\n\r\n                //return point of right most valid pixel.\r\n                return thispt;\r\n            case RIGHT:\r\n                //Get data from right neighbour\r\n                rightdata = mask.get(y, x+1)[0];\r\n\r\n                //Get data from lower neighbour\r\n                downdata = mask.get(y+1, x)[0];\r\n\r\n\r\n                //check neighbour data for valid pixel\r\n                if (rightdata > 0) return dfs(mask, y, x+1, type);\r\n                else if(downdata > 0) return dfs(mask, y+1, x, type);\r\n\r\n                //return point of right most valid pixel.\r\n                return thispt;\r\n\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /*https://github.com/opencv-java/object-detection/commit/b6c2afe355c34ff6b103961142f5f0e2601d024f*/\r\n    private BufferedImage matToBufferedImage(Mat original)\r\n    {\r\n        // init\r\n        BufferedImage image = null;\r\n        int width = original.width(), height = original.height(), channels = original.channels();\r\n        byte[] sourcePixels = new byte[width * height * channels];\r\n        original.get(0, 0, sourcePixels);\r\n\r\n        if (original.channels() > 1)\r\n        {\r\n            image = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);\r\n        }\r\n        else\r\n        {\r\n            image = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);\r\n        }\r\n        final byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();\r\n        System.arraycopy(sourcePixels, 0, targetPixels, 0, sourcePixels.length);\r\n\r\n        return image;\r\n    }\r\n\r\n    public static void main (String [] args){\r\n\r\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\r\n\r\n        ColorDetection cd = new ColorDetection(\"res/Board.jpg\");\r\n        cd.frame.setPreferredSize(new Dimension(1800, 900));\r\n        cd.frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // reag√©r paa luk\r\n        cd.frame.pack();                       // saet vinduets stoerrelse\r\n        cd.frame.setVisible(true);                      // aabn vinduet\r\n\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/ColorDetection.java	(revision 5b0f10d239b674747f7bb22b9a98d8d392525585)
+++ src/ColorDetection.java	(date 1587413119636)
@@ -74,8 +74,11 @@
                 break;
             }
         }
+        double start = System.currentTimeMillis();
         Rect t1 = getSubSqr(resized_mask, (int) ys, (int) xs);
+        double end = System.currentTimeMillis();
 
+        System.out.println("Time spent (ms): " + (end - start));
 /*
         ArrayList values = new ArrayList<>();
 
Index: .idea/codeStyles/Project.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/codeStyles/Project.xml	(date 1587412424261)
+++ .idea/codeStyles/Project.xml	(date 1587412424261)
@@ -0,0 +1,7 @@
+<component name="ProjectCodeStyleConfiguration">
+  <code_scheme name="Project" version="173">
+    <ScalaCodeStyleSettings>
+      <option name="MULTILINE_STRING_CLOSING_QUOTES_ON_NEW_LINE" value="true" />
+    </ScalaCodeStyleSettings>
+  </code_scheme>
+</component>
\ No newline at end of file
Index: .idea/codeStyles/codeStyleConfig.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/codeStyles/codeStyleConfig.xml	(date 1587412424290)
+++ .idea/codeStyles/codeStyleConfig.xml	(date 1587412424290)
@@ -0,0 +1,5 @@
+<component name="ProjectCodeStyleConfiguration">
+  <state>
+    <option name="PREFERRED_PROJECT_CODE_STYLE" value="Default" />
+  </state>
+</component>
\ No newline at end of file
